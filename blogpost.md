# Our brand new .NET server helper libraries and Awesome Interface driven Rest clientA couple of weeks ago we released a new suite of .NET server helper libraries to help you build server side apps even quicker. The old Sinch.SMS and Sinch.Core are now obsolete on nuget and from now on you should use our new version:```powershellPM> Install-Package Sinch.ServerSdk```And for WebAPIs we have a an extension ```powershellPM> Install-Package Sinch.ServerSdk.Callback.WebApi```If I may say so they are awesome nugets that will help you build stuff super quick, you can read more about that in the following tutorials:* [https://github.com/sinch/net-demo.sinch.com](https://github.com/sinch/net-demo.sinch.com)* [https://www.sinch.com/tutorials/send-sms-c/](https://www.sinch.com/tutorials/send-sms-c/)* [https://www.sinch.com/tutorials/receive-sms-sinch-net-server-side-sdk/](https://www.sinch.com/tutorials/receive-sms-sinch-net-server-side-sdk/)In this post I want to talk about a little hidden Gem that the team has made. The Sinch.WebApiClient that is used be the above packages is open sourced on [GitHub](https://github.com/sinch/nuget-webapiclient) and is kind of wrapper library for managing and signing requests to our backend (you know how boring it is to deal with security ;). The cool thing is that it lets you create new requests with interfaces and filters so you can easily extend our and your own APIs both on the server and client and still have the nice typing. Just the other week I found it extremely useful when our backend team released some new code but our SDK team was just a little bit behind. With just a couple of minutes of looking at the documentation over for a new request ([Callouts](https://www.sinch.com/docs/voice/rest/#Callouts) ), I could still use the current Nuget form the SDK team. To do that I created an interface in my solution```csharppublic interface ICalloutApiEndpoints {    [HttpPost("calling/v1/callouts/")]    Task<SendSmsResponse> AddParticipant([ToBody] CalloutRequest request);}public class Destination {    public string type { get; set; }    public string endpoint { get; set; }}public class ConferenceCallout {    public string cli { get; set; }    public Destination destination { get; set; }    public string domain { get; set; }    public string custom { get; set; }    public string locale { get; set; }    public string greeting { get; set; }    public string conferenceId { get; set; }    public bool enableDice { get; set; }}public class CalloutRequest {    public string method { get; set; }    public ConferenceCallout conferenceCallout { get; set; }}```The attribute [ToBody] indicates that that parameter should be serialized to the body, there is a [ToURI] where you would add it to the URI instead. Just the request as specified in the docs. Now to use this you only have to create an APIFactory with this interface: ```csharpvar factory = new WebApiClientFactory()				.CreateClient<ICalloutApiEndpoints>					("https://api.sinch.com",                    	new ApplicationSigningFilter(appKey, Convert.FromBase64String(appSecret)), 					new RestReplyFilter());await factory.AddParticipant(new CalloutRequest    {        method = "conferenceCallout",        conferenceCallout = new ConferenceCallout        {            cli = "+17864088194",            destination = new Destination {endpoint = "+15612600684", type = "number"},            domain = "pstn",            conferenceId = conferenceId,            enableDice = true        }    });```And the WepAPI client will take care of the signing of the requests and all for you. Super simple and super sweet.Over and out/Chris